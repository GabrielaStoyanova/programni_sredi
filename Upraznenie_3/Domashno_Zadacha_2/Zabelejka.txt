Реших да пробвам друг вариант, за да могат и двата логера да работят едновременно, единият при успешен вход, другият при неуспешен,
защото досега използвах един LoggerProvider, в който си връщам логера, който ми трябва за съответната задача, като другите return 
изрази за другите логери за закоментарени. Тук създавам още един клас ErrorLoggerProvider, който ми служи като такъв само за неуспешен
вход, а LoggerProvider вече връща логера за успешен вход. В ErrorLoggerProvider използвам вече създадения от мен FileLogger, който пише
във файл, за да запиша въведеното от потребителя име и парола, които ги няма в хардкоднатите потребители. В LoggerHelper си правя още 
един метод за getErrorLogger с LoggerFactory() към ErrorLoggerProvider. В Delegates дефинирам още една променлива _errorLogger от тип
ILogger, която използва новосъздадения метод от LoggerHelper => LoggerHelper.GetErrorLogger("ErrorLogger");. След това правя още един
Log5 метод, с който складирам LogInformation подаден като параметър. Най-накрая в program.cs в частта, където се проверят данните 
въведени от потребителя, в частта от if statement-а, където той не е верен, а това е когато въведените парола и име от потребителя 
не съществуват, се записват във файла грешните парола и име, които са въведени при опит за влизане, това става чрез делегата от клас
ActionOnError, на който му се подава като аргумент Log5 метода от файл delegates.cs. С това решение програмата ми успешно имплементира 
работата и на двата логера при успешен и неуспешен вход, което се вижда в създадените текстови файла в bin папката на проекта, в който
е вписана информацията относно опитаните от мен грешни и верни логвания за тестване.
